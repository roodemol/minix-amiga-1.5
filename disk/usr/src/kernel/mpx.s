#include <minix/config.h>
#include "const.h"
#if (MACHINE == AMIGA)

!
! Only the registers that are considered scratch by the compiler used
! to compile the kernel are saved. Other registers are saved by the
! prolog generated by the kernel compiler.
!
#define FREEREGS d0-d2/a0-a1

! section definition
	.sect   .text
	.sect   .rom
	.sect   .data
	.sect   .bss

!
! public labels
!
	.define _lock
	.define _unlock
	.define _restore
	.define _reboot
	.define _sizes
	.define .trpim
	.define .trppc

!
! external references
!
	.extern _clock_handler
	.extern _held_head
	.extern _k_reenter
	.extern _proc_ptr
	.extern _rdy_head
	.extern _lock_pick_proc
	.extern _main
	.extern _trap

	.extern _dskblk_int
	.extern _dsksyn_int
	.extern _ciaa_int
	.extern _ciab_int
	.extern _vbl_int
	.extern _aud_int
	.extern _nmi_int
	.extern _sys_call

!
! offsets into a proc table entry
!
sava6   = 56
savsp   = 60
savpc   = 64
savsr   = 68
savtt   = 77

	.sect   .text

.data2	0,	0,	0,	start,	0x0200,	err,	0x0300,	err
.data2	0x0400,	trp,	0x0500,	trp,	0x0600,	trp,	0x0700,	trp
.data2	0x0800,	trp,	0x0900,	trc,	0x0A00,	trp,	0x0B00,	trp
.data2	0x0C00,	trp,	0x0D00,	trp,	0x0E00,	trp,	0x0F00,	trp
.data2	0x1000,	non,	0x1100,	non,	0x1200,	non,	0x1300,	non
.data2	0x1400,	non,	0x1500,	non,	0x1600,	non,	0x1700,	non
.data2	0x0000,	intr,	0x0100,	intr,	0x0200,	intr,	0x0300,	intr
.data2	0x0400,	intr,	0x0500,	intr,	0x0600,	intr,	0x0700,	intr
.data2	0,	sys,	0x2100,	trp,	0x2200,	trp,	0x2300,	trp
.data2	0x2400,	trp,	0x2500,	trp,	0x2600,	trp,	0x2700,	trp
.data2	0x2800,	trp,	0x2900,	trp,	0x2A00,	trp,	0x2B00,	trp
.data2	0x2C00,	trp,	0x2D00,	trp,	0x2E00,	trp,	0x2F00,	trp
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0
.data2	0,	0,	0,	0,	0,	0,	0,	0

!
! startup code, just after interrupt vectors
! clear bss (uninitialized data) section
! call _main and do process switch when it returns
!
start:
	move.w	#0x2700,sr
	move.l	#k_stktop,sp
	jsr	_main
	bra	restart

!
! The vector handlers for synchronous traps. save full context.
!
err:
	add.l	#8,sp		! remove extra context
trp:
	bsr     save
	jsr     _trap
	bra     restart
trc:
	btst    #5,(sp)			! tracing through trap?
	beq     trp			! No, do normal trace processing
non:	rte				! don't trace; execute system call
sys:
	bsr     save			! d0, d1 and a0 not modified
	move.l  a0,-(sp)		! m_ptr
	move.w  d1,-(sp)		! src_dest
	move.w  d0,-(sp)		! SEND/RECEIVE/BOTH
	move.l  _proc_ptr,a6		! needed to store return value
					! warning: _sys_call may change _proc_ptr
	jsr     _sys_call		! sys_call(func,src_dest,m_ptr)
	move.l  d0,(a6)
	add.l   #8,sp
	bra     restart

intr:
	movem.l	FREEREGS,-(sp)
	clr.l   d0
	jsr	trick
trick:	move.b	(sp),d0			! PC (high 8 bits) -> D0
	add.l	#4,sp			! remove return address

	lsl	#2,d0
	lea	jmpint,a0
	move.l	0(a0,d0),a0
	add.b   #1,_k_reenter		! from -1 if not reentering
	jsr     (a0)			! call service routine

	move.w  #0x2700,sr
	sub.b   #1,_k_reenter
	movem.l (sp)+,FREEREGS
	btst    #5,(sp)			! previously in kernel mode?
					! (interrupted a task or another interrupt)
	bne     L3	                ! yes: branch and return from interrupt
	cmp.l   #0,_rdy_head+TASK_Q     ! any task just readied?
	bne     L4	                ! yes: branch and do task switch

	cmp.l	#0,_held_head		! are there unserviced interrupts?
	bne	L4			! yes: let restart take care
L3:
	rte
L4:
	bsr     save
	jsr     _lock_pick_proc
	bra     restart
!
! Perform task switch by save and restart
!
save:
	move.w  #0x2700,sr	                                ! ?
	move.l  a6,-(sp)
	move.l  _proc_ptr,a6
	movem.l d0-d7/a0-a5,(a6)
	move.l  (sp)+,sava6(a6)			! a6
	lea     10(sp),a1
	btst    #5,4(sp)			! test old S-bit
	bne     L5				! jump if S-bit on
	move.l  usp,a1
L5:     move.l  a1,savsp(a6)			! old sp: usp or ksp
	move.b  (sp),savtt(a6)			! trap type
	clr.b   (sp)				! cleanup
	move.l  (sp)+,a1			! return address
	move.w  (sp)+,savsr(a6)			! sr
	move.l  (sp)+,savpc(a6)			! pc
	add.b   #1,_k_reenter			! from -1 if not reentering
	move.l  #k_stktop,sp    
	jmp     (a1)

restart:
! Flush any held-up interrupts.
! This reenables interrupts, so the current interrupt handler may reenter.
! This doesn't matter, because the current handler is about to exit and no
! other handlers can reenter since flushing is only done when k_reenter == 0.

	move.w  #0x2700,sr
	tst.b   _k_reenter
	bne     over_call_unhold
	cmp.l   #0,_held_head
	beq     over_call_unhold
	jsr     _unhold
over_call_unhold:
	sub.b   #1,_k_reenter
	jsr     _checksp
	move.l  _proc_ptr,a6
	move.l  savsp(a6),a0			! old sp: usp or ksp
	btst    #5,savsr(a6)			! test old S-bit
	bne     L6				! jump if S-bit on
	move.l  a0,usp
	bra     L7
L6:     move.l  a0,sp
L7:     move.l  savpc(a6),-(sp)			! pc
	move.w  savsr(a6),-(sp)			! sr
	movem.l (a6),d0-d7/a0-a6
	rte

_lock:
	move.w  sr,d0
	move.w  #0x2700,sr
	rts
_restore:
	move.w  4(sp),sr
	rts
_unlock:
	move.w  #0x2000,sr
	rts
_reboot:
	jmp	start

	.sect   .data

_sizes:
	.data2  0x526F,0,0,0,0,0,0,0

jmpint:
	.data4	0,		_dskblk_int,	_ciaa_int,	_vbl_int
	.data4	_aud_int,	_dsksyn_int,	_ciab_int,	_nmi_int

	.space K_STACK_BYTES
k_stktop:

	.sect   .text
	.extern _write
	.extern EXIT
_write:
EXIT:
	bra     EXIT

	.sect   .text
.trpim: .data2  0
.trppc: .data4  0

#endif
